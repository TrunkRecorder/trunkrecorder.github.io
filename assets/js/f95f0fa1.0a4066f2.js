"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[727],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>g});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},s=Object.keys(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),c=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),m=n,g=d["".concat(l,".").concat(m)]||d[m]||h[m]||s;return a?r.createElement(g,i(i({ref:t},p),{},{components:a})):r.createElement(g,i({ref:t},p))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:n,i[1]=o;for(var c=2;c<s;c++)i[c]=a[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},2135:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=a(7462),n=(a(7294),a(3905));const s={},i="Object Lifecycles and States in Trunk Recorder",o={unversionedId:"notes/STATES",id:"notes/STATES",title:"Object Lifecycles and States in Trunk Recorder",description:"Calls, Recorders and the Wav file write associated with a recorder all go through a lifecycle and have different states associated with each stage of the lifecycle.",source:"@site/docs/notes/STATES.md",sourceDirName:"notes",slug:"/notes/STATES",permalink:"/docs/notes/STATES",draft:!1,editUrl:"https://github.com/TrunkRecorder/trunkrecorder.github.io/tree/main/docs/notes/STATES.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Plugin System",permalink:"/docs/notes/PLUGIN-SYSTEM"},next:{title:"Status json messages",permalink:"/docs/notes/STATUS-JSON"}},l={},c=[{value:"Calls",id:"calls",level:2},{value:"Trunked System",id:"trunked-system",level:3},{value:"New Calls",id:"new-calls",level:4},{value:"Object States",id:"object-states",level:2},{value:"Recorders",id:"recorders",level:3},{value:"Calls",id:"calls-1",level:3}],p={toc:c},d="wrapper";function h(e){let{components:t,...a}=e;return(0,n.kt)(d,(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"object-lifecycles-and-states-in-trunk-recorder"},"Object Lifecycles and States in Trunk Recorder"),(0,n.kt)("p",null,"Calls, Recorders and the Wav file write associated with a recorder all go through a lifecycle and have different states associated with each stage of the lifecycle."),(0,n.kt)("h2",{id:"calls"},"Calls"),(0,n.kt)("p",null,"Calls are the highest level object. They represent a frequency being reserved for use by a talkgroup. Calls in a ",(0,n.kt)("strong",{parentName:"p"},"Conventional")," systems are handled slightly differently than Calls in a ",(0,n.kt)("strong",{parentName:"p"},"Trunked")," system."),(0,n.kt)("h3",{id:"trunked-system"},"Trunked System"),(0,n.kt)("h4",{id:"new-calls"},"New Calls"),(0,n.kt)("p",null,"The Trunking Messages for each system get decoded and placed into a message queue. In ",(0,n.kt)("em",{parentName:"p"},"main.cc")," the ",(0,n.kt)("strong",{parentName:"p"},"monitor_messages()")," pulls messages off the queue and passes them to ",(0,n.kt)("strong",{parentName:"p"},"handle_message()")," for processing. When a new ",(0,n.kt)("strong",{parentName:"p"},"GRANT")," or ",(0,n.kt)("strong",{parentName:"p"},"UPDATE")," comes in, the message is passed to ",(0,n.kt)("strong",{parentName:"p"},"handle_call()"),". "),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"handle_call()")," starts by going through all of the existing Calls and seeing if there is an active Call that already covers the ",(0,n.kt)("strong",{parentName:"p"},"GRANT")," or ",(0,n.kt)("strong",{parentName:"p"},"UPDATE"),". This means that the existing Call has the same:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"talkgroup"),(0,n.kt)("li",{parentName:"ul"},"system"),(0,n.kt)("li",{parentName:"ul"},"frequency"),(0,n.kt)("li",{parentName:"ul"},"TDMA Slot"),(0,n.kt)("li",{parentName:"ul"},"Phase 1 / Phase 2\n... and the Call has a state or ",(0,n.kt)("strong",{parentName:"li"},"RECORDING")," or ",(0,n.kt)("strong",{parentName:"li"},"MONITORING")," (more on these in a little).")),(0,n.kt)("p",null,"If there is an existing Call that covers all of this, then it will simply be updated."),(0,n.kt)("p",null,"If not, a new Call is created and an attempt to start a recording is made by calling ",(0,n.kt)("strong",{parentName:"p"},"start_recorder()"),". ",(0,n.kt)("strong",{parentName:"p"},"start_recorder()")," first checks to see if a talkgroup entry is defined in the ",(0,n.kt)("em",{parentName:"p"},"talkgroup.csv")," file for the talkgroup number in the message. If the ",(0,n.kt)("strong",{parentName:"p"},"recordUnknown")," flag is set to false in the ",(0,n.kt)("em",{parentName:"p"},"config.json")," and a talkgroup entry is not found, then a recording will not be started.\nEncrypted transmissions are not recorded. If a talkgroup entry does exist and the talkgroup is marked as encrypted, it will be skipped. The same is true if the message's encrypted flag is set."),(0,n.kt)("p",null,"After these checks, ",(0,n.kt)("strong",{parentName:"p"},"start_recorder()")," will now try to assign a recorder. It does this by going through the Sources and finding the first one that covers the frequency in the message. The function will then try to get either an analog or digital recorder from the Source by calling ",(0,n.kt)("strong",{parentName:"p"},"get_analog_recorder()")," or ",(0,n.kt)("strong",{parentName:"p"},"get_digital_recorder()"),", respectively. The ",(0,n.kt)("strong",{parentName:"p"},"get_analog_recorder()")," and ",(0,n.kt)("strong",{parentName:"p"},"get_digital_recorder()")," functions in ",(0,n.kt)("em",{parentName:"p"},"source.cc")," simply go through the vector of Recorders that were created for that Source and checking their state. The first recorder with the state of ",(0,n.kt)("strong",{parentName:"p"},"available")," is returned. For both types of recorders, their state actually comes from transmission_sink block that is at the end of the recorders gnuradio graph. We will dive into that lifecycle later. The transmission_sink block that part of the recorder, will receive some information about the call and will set its state to ",(0,n.kt)("strong",{parentName:"p"},"idle")),(0,n.kt)("p",null,"Back in ",(0,n.kt)("em",{parentName:"p"},"main.cc"),", if a recorder was return, it is associated with the call and the call's state is set to ",(0,n.kt)("strong",{parentName:"p"},"recording"),". If it wasn't possible to get a recorder, the call's state is set to ",(0,n.kt)("strong",{parentName:"p"},"monitoring"),". This serves to track that the Talkgroup will be on that frequency and that Trunk Recorder does not have to try and assign a recorder everytime it gets an ",(0,n.kt)("strong",{parentName:"p"},"UPDATE")," trunking message."),(0,n.kt)("p",null,"When a ",(0,n.kt)("strong",{parentName:"p"},"GRANT")," or ",(0,n.kt)("strong",{parentName:"p"},"UPDATE")," message comes in and goes through ",(0,n.kt)("strong",{parentName:"p"},"handle_call()"),", the function will see that a call has already been assigned and will call that call's ",(0,n.kt)("strong",{parentName:"p"},"update()")," function. This function simply sets the call's ",(0,n.kt)("em",{parentName:"p"},"last_update")," variable to the current time. "),(0,n.kt)("p",null,"As voice samples make their way through the recorder, they eventually end up in the ",(0,n.kt)("strong",{parentName:"p"},"transmission_sink.cc")," block. When a wav_sink and its recorder are first associated with a call, its state is initially set to ",(0,n.kt)("strong",{parentName:"p"},"idle"),". When in ",(0,n.kt)("strong",{parentName:"p"},"idle")," and a voice sample comes in, the wav_sink will change its state to ",(0,n.kt)("strong",{parentName:"p"},"recording"),", open a new file and being writing samples to it. The wav_sink starts a ",(0,n.kt)("em",{parentName:"p"},"Transmission")," which tracks each of the individual transmissions that make up a call on a digital system. The variable ",(0,n.kt)("em",{parentName:"p"},"d_stop_time")," is also updated with the current time. This is used in analog systems to determine is there has been a break in writing to the file, signaling a new file should be started. "),(0,n.kt)("p",null,"In digital system, a Terminator Data Unit (TDU) is sent on the voice channel at the start and end of the call. The digital recorder processes this and passes it along to the wav_sink. When the wav_sink is in the state ",(0,n.kt)("strong",{parentName:"p"},"recording"),", signifying it has written samples to a file, and it receives a TDU it will end the current transmission. The wav_sink has an internal flag called ",(0,n.kt)("em",{parentName:"p"},"record_more_transmissions"),". If this flag is set to ",(0,n.kt)("em",{parentName:"p"},"false")," the wav_sink's state will be set to ",(0,n.kt)("strong",{parentName:"p"},"stopped"),", otherwise it will be set to ",(0,n.kt)("strong",{parentName:"p"},"idle"),". When a wav_sink is in state ",(0,n.kt)("strong",{parentName:"p"},"stopped"),", any voice samples that come in will be dropped and not written to a file, and new Transmission will not be created. However, when the state is ",(0,n.kt)("strong",{parentName:"p"},"idle"),", it will operate like it was just created."),(0,n.kt)("h2",{id:"object-states"},"Object States"),(0,n.kt)("h3",{id:"recorders"},"Recorders"),(0,n.kt)("p",null,"(we need an extra state beyond stopped. when it is stopped, a recorder could still be associated with a call and the call completer has not been called yet. it goes into available when there are no more call associated with it)\n(if a Recorder misses the terminator messages, it can be stuck in RECORDING state. The main.cc idle check will clear stuck calls.)"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"available")," The recorder does not have a call associated with it. There are no active transmissions."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"idle")," The recorder has an associated call. The recorder is waiting for samples to come in. There are no active transmissions. when it is in this state an receives a sample, it will start a transmission and open a file."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"recording")," The recorder has an associated call. There is an open transmission and file. When the recorder receives a Terminating Data Unit (TDU) tag, it will end the current transmission and close the file. If the ",(0,n.kt)("em",{parentName:"li"},"record_more_transmissions")," flag has been set to ",(0,n.kt)("em",{parentName:"li"},"false")," it will then set its state to ",(0,n.kt)("strong",{parentName:"li"},"stopped"),", if it is ",(0,n.kt)("em",{parentName:"li"},"true")," it will set its state to ",(0,n.kt)("strong",{parentName:"li"},"idle")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"stopped")," The recorder has an associated call. There are no active transmissions or open files. When ",(0,n.kt)("strong",{parentName:"li"},"stop_recording()")," is called, signifying that the call is complete, the state will be set back to ",(0,n.kt)("strong",{parentName:"li"},"available"),".")),(0,n.kt)("h3",{id:"calls-1"},"Calls"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"recording")," or ",(0,n.kt)("strong",{parentName:"li"},"monitoring")," - This is the initial state for a call. The call has recently received an UPDATE or GRANT message on the control channel. When the state is ",(0,n.kt)("strong",{parentName:"li"},"recording")," there is a Recorder associated with the call."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"inactive")," - A UPDATE or GRANT message has not been received for that call on the control channel within the timeout period (3 sec). The associated recorder is still has the state of ",(0,n.kt)("strong",{parentName:"li"},"recording"),", meaning that it has received samples and has not yet received a TDU. The recorder's ",(0,n.kt)("strong",{parentName:"li"},"record_more_transmissions")," flag will be set to ",(0,n.kt)("em",{parentName:"li"},"false"),". After the recorder receives a TDU or after a timeout period has elapsed (10s), the call state will transition to completed."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"completed")," - A UPDATE or GRANT message has not been received for that call on the control channel within the timeout period (3 sec). The associated recorder was in a state of ",(0,n.kt)("strong",{parentName:"li"},"idle")," or ",(0,n.kt)("strong",{parentName:"li"},"stopped"),". The recorder's ",(0,n.kt)("strong",{parentName:"li"},"record_more_transmissions")," flag gets set to ",(0,n.kt)("em",{parentName:"li"},"false"),". In the state ",(0,n.kt)("strong",{parentName:"li"},"completed")," a call can be concluded() and deleted.")))}h.isMDXComponent=!0}}]);